11a12
> 
22,23c23,24
< 	Variable/G root:myGlobals:gNPixelsX=192					// number of detector X and Y pixels
< 	Variable/G root:myGlobals:gNPixelsY=192
---
> 	Variable/G root:myGlobals:gNPixelsX=128					// number of X and Y pixels
> 	Variable/G root:myGlobals:gNPixelsY=128
26,29c27,36
< 	Variable/G root:myGlobals:PixelResDefault = 0.51	//pixel resolution in cm
< 	//No dead time measured for HFIR detector but the count rate is set very low. For now, set the detector perfect.
< 	// This should be updated when the condition is changed.   JHC 09/02/09
< 	Variable/G root:myGlobals:DeadtimeDefault =  0       //3.4e-6 (NIST value)	//deadtime in seconds
---
> //	Variable/G root:myGlobals:PixelResDefault = 0.5			//pixel resolution in cm
> 	
> 	Variable/G root:myGlobals:DeadtimeDefault =  (0.9e-6 )/128		//deadtime in seconds
> 	
> 	Variable/G root:myGlobals:BeamstopYTol = 100	
> 
> 	Variable/G root:myGlobals:apOff = 5.0		// (cm) distance from sample aperture to sample position
> 
> 	// changing behavior specific to ILL correction of data
> 	Variable/G root:myGlobals:gDoDetectorEffCorr = 1				//default state is ==1
31d37
< 	Variable/G root:myGlobals:apOff = 5.0		// (cm) distance from sample aperture to sample positio
138d143
< 
144,145c149,153
< // fileStr is passed as TextRead[3] and is the filename
< // detStr is passed as TextRead[9] and is an identifier for the detector
---
> // fileStr is passed as TextRead[3]
> // detStr is passed as TextRead[9]
> //
> // *** as of Jan 2008, depricated. Now detector pixel sizes are read from the file header
> // rw[10] = x size (mm); rw[13] = y size (mm)
152c160
< 	NVAR PixelResDefault = root:myGlobals:PixelResDefault
---
> 
154c162,165
< 	DDet = PixelResDefault	//0.515 cm, typical for new ORNL detectors
---
> //	DDet= getRealValueFromHeader_2(fileStr,60,28,5,11,5) 
> 	
> 	DDet = getRealValueFromHeader(filestr,55)
> 	
170d180
< 	NVAR DeadtimeDefault = root:myGlobals:DeadtimeDefault
172c182,184
< 	deadtime = DeadtimeDefault	//3.4e-6 seconds, typical for new ORNL detectors //???????????????????????????
---
> // your code here
> deadtime = (2e-6)
> 
177d188
< 
185c196,198
< //Because HFIR data format is w/ 2X 4digit number. We add them to get a unique number => This will cause the arrow button not working.
---
> //
> 
> //
188,189c201,202
< 	Variable invalid = -1	//negative numbers are invalid
< 	Variable num=-1
---
> 
> 	Variable num=-1		// an invalid return value
191d203
< 	//find the "dot"
193,221d204
< 	Variable pos = strsearch(item,".",0)
< 	if(pos == -1)
< 		//"dot" not found
< 		return (invalid)
< 	else
< 		//found, get the nine characters preceeding it
< 		if (pos <=8)
< 			//not enough characters
< 			return (invalid)
< 		else
< 			Variable pos_bio = strsearch( LowerStr(item),"biosans",0)
< 			//if  (pos_bio== -1)
< 				runStr  = item[pos-9,pos-6]  	//first 4 numbers
< 			//else
< 				runStr  += item[pos-4,pos-1]	//add last 4 numbers
< 			//endif
< 			//convert to a number
< 			num = str2num(runStr)
< 			
< 			//if valid, return it
< 			if (num == NaN)
< 				//8 characters were not a number
< 				return (invalid)
< 			else
< 				//run was OK
< 				return (num)
< 			Endif
< 		Endif
< 	Endif
222a206,213
> 	runStr = ParseFilePath(0, item, ":", 1, 0)
> //	runstr = item
> 	num = str2num(runstr)
> 	
> 	
> 	//your code here
> 	
> 	return (num)
225d215
< 
237,240c227
< // XXXXSANS_expXX._scan1234_5678.xmp ==> "12345678"
< // -- result is an 8-character string
< //
< Function/S GetRunNumStrFromFile(item)	//,numposition)
---
> Function/S GetRunNumStrFromFile(item)
242d228
< 	Variable numposition
246a233,236
> 	
> 	retstr = ParseFilePath(0, item, ":", 1, 0)
> 	//your code here
> 	
248,270d237
< 	//find the "dot"
< 	Variable pos = strsearch( LowerStr(item),".xml",0)
< 	if(pos == -1)
< 		//"dotxml" not found
< 		return (retStr)
< 	else
< 		pos = strsearch( LowerStr(item),"_scan",0)
< 		
< 		if  (pos == -1)
< 			//not a raw data file
< 			return (retStr)
< 		else
< 			//Variable pos_bio = strsearch( LowerStr(item),"biosans_",0)  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
< 			//if  (numposition == 0)
< 				//Take the first four: //HiResSANS
< 				retStr = item[pos+5,pos+8]
< 			//else	
< 				//add the last four: //BioSANS
< 				retStr += item[pos+10,pos+13]
< 			//Endif
< 			return (retStr)
< 		Endif
< 	Endif
271a239
> 	return(retStr)
286c254
< 
---
> 	
288,293d255
< 	//get list of raw data files in folder that match "num" (add leading zeros)
< 	if( (num>99999999) || (num<0) )
< 		//Print "error in  FindFileFromRunNumber(num), file number too large or too small"
< 		Return ("")
< 	Endif
< 	//make a four character string of the run number
296,323c258,282
< 	if(num > 9999999 && num < 100000000)
< 		numStr = num2istr(num)
< 	endif
< 	if(num > 999999 && num < 10000000)
< 		numStr = "0"+num2istr(num)
< 	endif	
< 	if(num > 99999 && num < 1000000)
< 		numStr = "00"+num2istr(num)
< 	endif	
< 	if(num > 9999 && num < 100000)
< 		numStr = "000"+num2istr(num)
< 	endif
< 	if(num > 999 && num < 10000)
< 		numStr =  "0000"+num2istr(num)
< 	endif
< 	if(num > 99 && num < 1000)
< 		numStr = "00000"+num2istr(num)
< 	endif	
< 	if(num > 9 && num < 100)
< 		numStr = "000000"+num2istr(num)
< 	endif	
< 	if(num < 10 && num >0)
< 		numStr = "0000000"+num2iStr(num)
< 	endif
< 	if(num == 0)
< 		numStr = "00000000"
< 	endif
< 
---
> 	numStr = num2str(num)
> 	// pad to 6 characters
> 	switch(strlen(numstr))	// numeric switch
> 		case 6:		// execute if case matches expression
> 			break						// exit from switch
> 		case 5:
> 			numStr = "0"+numStr
> 			break
> 		case 4:
> 			numStr = "00"+numStr
> 			break
> 		case 3:
> 			numStr = "000"+numStr
> 			break
> 		case 2:
> 			numStr = "0000"+numStr
> 			break
> 		case 1:
> 			numStr = "00000"+numStr
> 			break												
> 		default:							// optional default expression executed
> 	endswitch
> 	
> //	Print "numstr = ",numstr
> 	
329a289
> 	
331a292,293
> 	
> 	
336d297
< 
337a299
> 	
340c302
< 		// 1 - does item contain run number (as a string) "NAMESANS_expNN_scan####_####.xml" : Let's check the 8  nums.
---
> 		// 1 - does item contain run number (as a string) "TTTTTnnn.SAn_XXX_Tyyy"
343d304
< 		
345,348c306,308
< 			//find the run number, if it exists as a 8 character string
< 			testStr = GetRunNumStrFromFile(item)	//0)
< 			runFound= cmpstr(numStr,testStr)	//compare the three character strings, 0 if equal
< 			
---
> 			//find the run number, if it exists as a three character string
> 			testStr = GetRunNumStrFromFile(item)
> 			runFound = cmpstr(numStr,testStr)
350,351d309
< 				//the run Number was found
< 				//build valid filename
353d310
< 				
359a317
> 						//print fullname
364d321
< 			
368,369c325,328
< 	print "The run number (", numStr, " +- 1 ) does not exist... (Note: The run number is defined as 12345678 if the file name is NameSANS_exp##_scan1234_5678.xml)"
< 	Return ("")	//null return if file not found in list	
---
> 	Return ("")	//null return if file not found in list
> 	
> 	//your code here
> 	
371,372c330,331
< 
< 
---
> 	
> 	
376c335
< // same scheme to get 8-character string as in GetRunNumStrFromFile(item)
---
> // same scheme to get 6-character string as in GetRunNumStrFromFile(item)
380a340,366
> //	String fullName="",partialName="",item=""
> //	String numStr=""
> //	
> //	numStr = num2istr(num)
> //	// pad to 6 characters
> //	switch(strlen(numstr))	// numeric switch
> //		case 6:		// execute if case matches expression
> //			break						// exit from switch
> //		case 5:
> //			numStr = "0"+numStr
> //			break
> //		case 4:
> //			numStr = "00"+numStr
> //			break
> //		case 3:
> //			numStr = "000"+numStr
> //			break
> //		case 2:
> //			numStr = "0000"+numStr
> //			break
> //		case 1:
> //			numStr = "00000"+numStr
> //			break												
> //		default:							// optional default expression executed
> //	endswitch
> //	
> 
383,384c369,370
< 	//make 8 digit string from run number
< 	sprintf numStr,"%08u",num
---
> 	//make 6 digit string from run number
> 	sprintf numStr,"%06u",num
386c372,373
< 	if(strlen(numStr) > 8)
---
> 	//Print "numstr = ",numstr
> 	if(strlen(numstr) > 6)
392a380,382
> 	
> 	return(numstr)
> End
394,408c384
< //given a filename of a SANS data filename of the form
< //TTTTTnnn.SAn_TTT_Txxx
< //returns the prefix "TTTTT" as some number of characters
< //returns "" as an invalid file prefix
< //
< // HFIR writes out files with a "prefix" of the following -- since there is really no "prefix" 
< // like in the VAX scheme:
< //			newFileName = ReplaceString(".xml",textPath[0],"")		//removes 4 chars
< //			newFileName = ReplaceString("SANS",newFileName,"")		//removes 4 more chars = 8
< //			newFileName = ReplaceString("exp",newFileName,"")			//removes 3 more chars = 11
< //			newFileName = ReplaceString("scan",newFileName,"")		//removes 4 more chars = 15, should be enough?
< //
< //
< // -- so the raw data:		BioSANS_exp9_scan1828_0001.xml
< // -- translates to: 		Bio_9_1828_0001.AVE	
---
> // there is no prefix on D22 data files - they're just a run number
409a386
> // so return null
416,419d392
< // changed (Oct 2010) the naming for HFIR from ExecuteProtocol to:
< //			newFileName = GetPrefixStrFromFile(textPath[0])+GetRunNumStrFromFile(textPath[0])
< // -- translates to: 		BioSANS18280001.AVE
< //
422,440c395
< 	String invalid = ""	//"" is not a valid run prefix, since it's text
< 	Variable num=-1
< 	
< 	//find the "dash"
< 	String runStr=""
< 	Variable pos = strsearch(item,"_",0)
< 	if(pos == -1)
< 		//"dot" not found
< 		return (invalid)
< 	else
< 		//found
< 		if (pos <=3)
< 			//not enough characters
< 			return (invalid)
< 		else
< 			runStr = item[0,pos-1]
< 			return (runStr)
< 		Endif
< 	Endif
---
> 	return("")
445,448c400
< //function to test a binary file to see if it is a RAW binary SANS file
< //first checks the total bytes in the file (which for raw data is 33316 bytes)
< //**note that the "DIV" file will also show up as a raw file by the run field
< //should be listed in CAT/SHORT and in patch windows
---
> //function to test a file to see if it is a RAW SANS file
450,451c402
< //Function then checks the file fname (full path:file) for "RAW" run.type field
< //if not found, the data is not raw data and zero is returned
---
> // returns truth 0/1
457,472d407
< 	      
< 	String tempheadhfir                                            
< 	Variable ind=0
< 	Variable refNum
< 	
< 	//If not have .xml extension, return 0.
< 	if (stringmatch(fname,"*.xml") <1)
< 		print fname+": Failed. Not a *.xml file."
< 		return 0				//Not *.xml. Do nothing...
< 	endif
< 	//actually open the file
< 	refNum = XmlOpenFile(fname)	
< 	if (refNum < 0)
< 		print "==> "+ fname+ "\r  ==> Failed to load: Not a standard xml file format or broken.. Please check the file if properly written..."
< 		return 0 				//Not a xml file. Do nothing...
< 	endif
474,485c409,411
< 	// Check if  it is the SPICE version = 1.1
< 	Variable  item,i,ns = 0
< 	String thislocation
< 	if (refNum >0)
< 		ns = str2num(XMLstrFmXpath(refNum, "//SPICErack/@SPICE_version","",""))
< 	endif
< 	XmlCloseFile(refNum,0)
< 	if (ns <1.1)
< 		ns =0
< 	else
< 		ns =1
< 	endif
---
> 
> Variable refnum,totalBytes
> 	String testStr=""
487,488c413,446
< 	return ns
< End
---
> 	Open/R/T="????" refNum as fname
> 	//get the total number of bytes in the file
> 	FStatus refNum
> 	totalBytes = V_logEOF
> //	Print totalBytes
> 	FSetPos refNum,75
> 	FReadLine/N=3 refNum,testStr
> //	print teststr
> 	Close refNum
> 	
> 	if(totalBytes == 142317 && cmpstr(testStr,"RRR")==0)
> 		//true, is raw data file
> 		
> //		print "yes"
> 		Return(1)
> 		
> 		
> 	else
> 		//some other file
> 		
> //		print "no"
> 		Return(0)
> 	Endif
> 
> 
> 
> 
> //	if()
> //		//true, is raw data file
> //		Return(1)
> //	else
> //		//some other file
> //		Return(0)
> //	Endif
490,493d447
< // for HFIR data, both DIV and RAW are determined by looking for "*.xml"
< Function CheckIfDIVData(fname)
< 	String fname
< 	return(CheckIfRawData(fname))
495a450
> 
500,511c455
< // SRK MAR 2010 - apparently from what I can see in the files, the beam stop "out"
< // position is 25 mm for all four beam stop Y POSITIONS
< // - if one is larger, (in the hundreds of mm) then it's in, and the run is not a transmission
< // - so if all four y positions are less than (tol) 30 mm, call it a trans file
< //
< // there is a field for this in the header, write "True", so I don't need to guess again.
< // -- but this field is often incorrect - for some sample data ALL FILES were "True"
< // -- better to check the physical location every time
< //
< // tol changed to 401 per Gernot's experience 6/24/10
< //
< Function isTransFile(fName)   ///  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
---
> Function isTransFile(fName)
514,536c458,463
< 	Variable beamtrap_1y=0,beamtrap_2y=0,beamtrap_3y=0,beamtrap_4y=0,tol=401
< 	//Check by key "transsmission"
< //	if (stringmatch( getIsTrans(fName),"True")>0)
< //		return (1)
< //	else
< 		//Check from beam stop motor position
< 	//	if(your test here)
< 		beamtrap_1y=getRealValueFromHeader(fname,"//Motor_Positions/trap_y_101mm","mm")
< 		beamtrap_2y=getRealValueFromHeader(fname,"//Motor_Positions/trap_y_25mm","mm")
< 		beamtrap_3y=getRealValueFromHeader(fname,"//Motor_Positions/trap_y_50mm","mm")
< 		beamtrap_4y=getRealValueFromHeader(fname,"//Motor_Positions/trap_y_76mm","mm")
< 
< 	 	if (beamtrap_1y < tol && beamtrap_2y < tol && beamtrap_3y < tol && beamtrap_4y < tol)	
< 			//Write the flag ON
< 			Write_isTransmissionToHeader(fName,"True")
< 			return (1)
< 		else
< 			//some other file
< 			Write_isTransmissionToHeader(fName,"False")
< 			return (0)
< 		endif
< 		
< //	endif
---
> 	variable ypos
> 	NVAR yTol = root:myGlobals:BeamstopYTol
> 	
> 	ypos = getRealValueFromHeader(fname,15)
> 	
> //	print ypos
538,539c465,473
< 	return (0)
< End
---
> //  print ytol
> 	
> 	if(abs(ypos)>=ytol)
> //		//yes, its a transmisison file
> 
> //print "yes"
> 		Return(1)
> 	else
> //		//some other file
540a475,478
> //print "no"
> 		Return(0)
> 	Endif
> End
545,546c483
< //but the text field in the header WILL, if less than 3 characters were used for the 
< //user's initials, and can have leading spaces if prefix was less than 5 characters
---
> //but the text field in the header may
552,553c489
< // NO CHANGE NEEDED
< //
---
> // no change needed here
581d516
< 
592,593c527,528
< 	String retStr=partialName
< 
---
> 	String retStr=""
> 	
594a530,532
> 	
> 	
> 	
597a536
> 		//non-null return
599c538
< 	endif
---
> 	Endif
612c551
< 	endif
---
> 	Endif
620c559
< 	endif
---
> 	Endif
630c569
< 	endif
---
> 	Endif
634c573,575
< 
---
> // partialName;vers (to account for VAX filenaming conventions)
> // The partial name is tried first with no version number
> //
640a582,584
> 
> 
> 
646c590
< 
---
> 	
668c612
< 
---
> 		//print "ii=",ii
678c622
< 		
---
> 	
682a627,628
> 
> 
689c635
< // NO CHANGE NEEDED
---
> // NEEDS NO CHANGES
691d636
< 
721c666
< // NO CHANGE NEEDED
---
> // NEEDS NO CHANGES
723d667
< 
754c698
< // NO CHANGE NEEDED
---
> // NEEDS NO CHANGES
756d699
< 
782,784c725,728
< Function/S GetNameFromHeader(fName)
< 	String fName
< 	String temp, newName = ""
---
> Function/S GetNameFromHeader(fullName)
> 	String fullName
> 	String  temp,newName = ""
> 	
787c731,733
< 	//filename is 31-33 characters INSTRNAMESANS_exp##_scan####_####.xml (where # : numbers)
---
> 	//filename is 20 characters NNNNNxxx.SAn_NNN_NNN
> 	//want the first 8 characters, NNNNNxxx, then strip off any spaces at the beginning
> 	//NNNNN was entered as less than 5 characters
789d734
< 	Variable iimax =  strlen(fName)
791c736
< 		temp = fname[ii,iimax-1-4]		//characters ii,all of the name
---
> 		temp = fullname[ii,7]		//characters ii,7 of the name
797c742
< 	While(ii<iimax)
---
> 	While(ii<8)
804a750,752
> //      print newname
> 	//your code here
> 	
820a769
> //
823d771
< 
856d803
< 
872d818
< 		
882c828
< 
---
> 			//print runnum
900c846
< 
---
> 	
912d857
< 
920c865
< 
---
> //	print num
979c924
< Function AttenuationFactor(fileStr,lam,attenuation)
---
> Function AttenuationFactor(fileStr,lam,attenNo)
981c926,931
< 	Variable lam,attenuation  //    0 =< attenuation <= 100 (%) : where no attenuator stands for 0.
---
> 	Variable lam,attenNo
> 	
> 	Variable attenFactor
> 	make/O/N=4 Attenuators_ILL={1,147,902,2874}
> 	
> 	attenFactor = Attenuators_ILL[attenNo]
983c933
< 	Variable attenFactor=1
---
> //	print attenfactor
986d935
< 	attenFactor = 1- attenuation*0.01  //???Attenuate transmission
988c937
< 	return(attenFactor)
---
> 	return(1/attenFactor)
1001a951,953
> // modify for specific facilities by changing the "*.SA1*","*.SA2*","*.SA3*" stringmatch
> // items which are specific to NCNR
> //
1017c969
< 
---
> 	//print "num = ",num
1021c973
< 		//if( !stringmatch(item,"*HiResSANS*.xml") && !stringmatch(item,"*BioSANS*.xml"))
---
> 		if( !stringmatch(item,"*.SA1*") && !stringmatch(item,"*.SA2*") && !stringmatch(item,"*.SA3*") )
1023c975
< 				newlist += (item) + ";"    
---
> 				newlist += item + ";"
1025c977
< 		//endif
---
> 		endif
1038,1040d989
< // does it the "cheap" way, simply finding the ".SAn" in the file name
< // = does not check for proper byte length.
< //
1051a1001
> 	
1053a1004,1005
> 	
> 	
1055,1066c1007,1017
< 		item = StringFromList(ii, list  ,";")
< 		if( stringmatch(item,"*.xml") )
< 			if (CheckIfRawData(S_path+item) >0)
< 				newlist += item + ";"
< 			endif
< 		endif
< 		// if condition is in here twice, not sure why since they are both "*.xml"
< //		if( stringmatch(item,"*.xml") )
< //			if (CheckIfRawData(S_path+item) >0)
< //				newlist += item + ";"
< //			endif
< //		endif
---
> 	item = StringFromList(ii, list  ,";")
> //	if( stringmatch(item,"*") )
> 	//		newlist += item + ";"
> //	endif
> 	if( stringmatch(item,"!*.*") )
> 			newlist	+= item + ";"
> 			
> 		
> 	endif
> 	
> 	
1067a1019,1020
> 	
> 	// your code here
1069c1022,1025
< 	return(newList)
---
> 	
> //	print newlist
> 	
> 	return(newlist)
1085a1042,1054
> // a tube-by-tube correction that replaces our area detecor correction
> Function DetEffCorrILL(lambda,dtdist,xd)  
> 	Variable lambda,dtdist,xd
> 	Variable ff=1,theta
>  
> 	theta =360* atan( xd/dtdist )/(2*Pi)
>  
> 	if (lambda <=5.1 && lambda>=4.9)
> 		ff= 1.000087- 7.094023e-5*abs(theta) + 8.622997e-5*abs(theta^2) + 9.262026e-6*abs(theta^3) -3.216369e-7*abs(theta^4) +2.142398e-9*abs(theta^5)
> 	elseif  (lambda <=8.1 && lambda>=7.9)
> 		ff= 0.9993575- 0.0002320264*abs(theta) + 9.751713e-5*abs(theta^2) + 1.018564e-5*abs(theta^3) -3.977445e-7*abs(theta^4) +2.960205e-9*abs(theta^5)
> 	endif
> 	ff= 0.9992674-0.0001808763*abs(theta) +8.134414e-05*abs(theta^2) +1.151734e-05*abs(theta^3) - 4.401022e-07*abs(theta^4)+3.71246e-09*abs(theta^5)
1086a1056,1057
> 	return(ff)
> End
1104c1075
< 	fileName = FindPrevNextRawFile(curfilename, prevnext)
---
> 	fileName = FindFileFromRunNumber(num+prevnext)
1111c1082
< 	//print "in FU "+filename
---
> //	print "in FU "+filename
1114,1158c1085
< End
< 
< // Find next or previous file name w/ current file name given.
< // Sort the list of files and get the next/previous file name.
< Function/S FindPrevNextRawFile(curfilename, prevnext)
< 	String curfilename
< 	Variable prevnext
< 	
< 	String fullName="",partialName="",item="", list=""
< 	Variable numItems,isRAW
< 			
< 	//make sure that path exists
< 	PathInfo catPathName
< 	String path = S_path
< 	
< 	if (V_flag == 0)
< 		Abort "folder path does not exist - use Pick Path button"
< 	Endif
< 
< 	
< 	list = SortList(IndexedFile(catPathName,-1,"????"),";")	//get all files in folder and make sure it is sorted.
< 	
< 	//find (the) one with the number in the run # location in the name
< 
< 	numItems = ItemsInList(list,";")		//get the new number of items in the list
< 	//index of curfilename
< 	Variable index = WhichListItem(curfilename,list,";",0,0)
< 	//get the prenextitem in the list
< 	item = StringFromList(index+prevnext, list  ,";")
< 	partialName = FindValidFileName(item)
< 	
< 	if(strlen(partialName) != 0)		//non-null return from FindValidFileName()
< 		fullName = path + partialName
< 		//check if RAW, if so,this must be the file!
< 		isRAW = CheckIfRawData(fullName)
< 		if(isRaw)
< 			//stop here
< 			return(fullname)
< 		Endif
< 	Endif
< 
< 	print "Please type 'scan number(s)' from your file name..."
< 	Return ("")	//null return if file not found in list	
< End
< 
---
> End
\ No newline at end of file
